from __future__ import annotations

import asyncio
import json
import threading
import time
from dataclasses import asdict
from typing import Any, Dict, Optional

import numpy as np
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles

from aircraft_simulator.sim.aircraft.aerodynamics import ControlInputs
from aircraft_simulator.sim.aircraft.forces_moments import ActuatorLimits, forces_and_moments_body
from aircraft_simulator.sim.aircraft.parameters import AircraftParameters
from aircraft_simulator.sim.aircraft.database import get_aircraft_model
from aircraft_simulator.sim.analysis.trim import compute_level_trim_guess
from aircraft_simulator.sim.control.linearize import linearize
from aircraft_simulator.sim.model import xdot_full
from aircraft_simulator.sim.control.actuators import ActuatorState
from aircraft_simulator.sim.control.autopilot import Autopilot, AutopilotTargets
from aircraft_simulator.sim.control.failure_modes import FailureManager
from aircraft_simulator.sim.dynamics.equations import derivatives_6dof, post_step_sanitize, rotation_body_to_inertial
from aircraft_simulator.sim.dynamics.integrator import rk4_step
from aircraft_simulator.sim.environment.wind import WindModel
from aircraft_simulator.sim.sensors.airspeed import AirspeedSensor
from aircraft_simulator.sim.sensors.altimeter import Altimeter
from aircraft_simulator.sim.sensors.compass import Compass
from aircraft_simulator.sim.sensors.imu import IMU
from aircraft_simulator.sim.state import State


from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent
FRONTEND_DIR = BASE_DIR / "frontend"
PLOTS_DIR = BASE_DIR / "plots"

app = FastAPI(title="Aircraft Simulator API", version="0.1.0")

# Allow local frontend dev servers
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3000",
        "http://127.0.0.1:3000",
        "http://localhost:5173",
        "http://127.0.0.1:5173",
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Serve frontend (+ plots generated by scripts)
if FRONTEND_DIR.exists():
    app.mount("/static", StaticFiles(directory=str(FRONTEND_DIR), html=True), name="static")
if PLOTS_DIR.exists():
    app.mount("/static/plots", StaticFiles(directory=str(PLOTS_DIR), html=False), name="plots")


@app.get("/")
def root() -> FileResponse:
    index_path = FRONTEND_DIR / "index.html"
    if index_path.exists():
        return FileResponse(str(index_path))
    return {"error": "Frontend index.html not found"}


class SimRuntime:
    def __init__(self):
        self.lock = threading.Lock()

        self.selected_aircraft_id = "cessna_172r"
        self.params = AircraftParameters()
        self.limits = ActuatorLimits()

        self.state = State(x=0.0, y=0.0, z=-1000.0, u=35.0, v=0.0, w=0.0)
        self.t = 0.0

        self.dt = 0.02
        self.running = False

        self.targets = AutopilotTargets(airspeed_mps=35.0, altitude_m=1000.0, heading_rad=0.0)
        self.autopilot_enabled = True

        self.ap = Autopilot()
        self.act = ActuatorState(tau_s=0.15, limits=self.limits)
        self.act.reset(ControlInputs(throttle=0.5))
        self.failures = FailureManager()

        self.seed = 7
        self.wind = WindModel(steady_ned_mps=np.zeros(3), seed=self.seed)
        self.altimeter = Altimeter(seed=self.seed + 1)
        self.airspeed_sensor = AirspeedSensor(seed=self.seed + 2)
        self.compass = Compass(seed=self.seed + 3)
        self.imu = IMU(seed=self.seed + 4)

        self.last_packet: Dict[str, Any] = {}

    def select_aircraft(self, aircraft_id: str) -> Dict[str, Any]:
        model = get_aircraft_model(aircraft_id)
        with self.lock:
            self.selected_aircraft_id = model.id
            self.params = model.params
            self.limits = model.limits
            self.state = State(x=0.0, y=0.0, z=-1000.0, u=35.0, v=0.0, w=0.0)
            self.t = 0.0

            self.ap = Autopilot()
            self.act = ActuatorState(tau_s=0.15, limits=self.limits)
            self.act.reset(ControlInputs(throttle=0.5))
            self.failures = FailureManager()

        return {
            "id": model.id,
            "name": model.name,
            "classification": model.classification,
            "stability_mode": model.stability_mode,
        }

    def set_wind(self, n: float, e: float, d: float) -> None:
        with self.lock:
            self.wind.steady_ned_mps = np.array([n, e, d], dtype=float)

    def set_targets(self, V: Optional[float] = None, alt: Optional[float] = None, hdg_deg: Optional[float] = None) -> None:
        with self.lock:
            self.targets = AutopilotTargets(
                airspeed_mps=self.targets.airspeed_mps if V is None else float(V),
                altitude_m=self.targets.altitude_m if alt is None else float(alt),
                heading_rad=self.targets.heading_rad if hdg_deg is None else float(np.deg2rad(hdg_deg)),
            )

    def set_autopilot(self, enabled: bool) -> None:
        with self.lock:
            self.autopilot_enabled = bool(enabled)

    def step(self) -> Dict[str, Any]:
        with self.lock:
            s = self.state
            t = self.t
            dt = self.dt

            self.failures.step(t)

            x = s.as_vector()
            params = self.params
            limits = self.limits

            # wind, body transform
            w_ned = self.wind.step(dt)
            C_bi = rotation_body_to_inertial(s.phi, s.theta, s.psi)
            w_body = C_bi.T @ w_ned
            v_b = np.array([s.u, s.v, s.w], dtype=float)
            v_air_b = v_b - w_body

            # gravity in body for IMU
            g_i = np.array([0.0, 0.0, params.g_ms2], dtype=float)
            g_b = C_bi.T @ g_i

            meas: Dict[str, float] = {
                "altitude_m": self.altimeter.read(t, -float(s.z), dt),
                "airspeed_mps": self.airspeed_sensor.read(t, float(np.linalg.norm(v_air_b)), dt),
                "heading_rad": self.compass.read(t, float(s.psi), dt),
                "phi_rad": float(s.phi),
                "theta_rad": float(s.theta),
            }
            meas.update(
                self.imu.read(
                    t,
                    pqr_radps=np.array([s.p, s.q, s.r], dtype=float),
                    uvw_mps=v_b,
                    g_b_ms2=g_b,
                    dt=dt,
                )
            )
            meas = self.failures.apply_sensors(meas)

            u_cmd = ControlInputs(throttle=0.5)
            ap_debug: Dict[str, float] = {}
            if self.autopilot_enabled:
                u_cmd, ap_debug = self.ap.update(meas, self.targets, dt)
            u_cmd = self.failures.apply_actuator(u_cmd)
            u = self.act.update(u_cmd, dt)

            # dynamics (wind held constant within step)
            def f_dyn(ti: float, xi: np.ndarray) -> np.ndarray:
                si = State.from_vector(xi)
                C_bi_i = rotation_body_to_inertial(si.phi, si.theta, si.psi)
                w_body_i = C_bi_i.T @ w_ned
                v_b_i = np.array([si.u, si.v, si.w], dtype=float)
                v_air_b_i = v_b_i - w_body_i
                F, M, _ = forces_and_moments_body(si, u, params, limits, uvw_air_mps=v_air_b_i)
                return derivatives_6dof(ti, xi, params, F, M)

            x = rk4_step(f_dyn, t, x, dt)
            x = post_step_sanitize(x)
            s_next = State.from_vector(x)

            self.state = s_next
            self.t = t + dt

            packet = {
                "t": float(self.t),
                "truth": {
                    "x": float(s_next.x),
                    "y": float(s_next.y),
                    "z": float(s_next.z),
                    "altitude_m": -float(s_next.z),
                    "phi": float(s_next.phi),
                    "theta": float(s_next.theta),
                    "psi": float(s_next.psi),
                    "u": float(s_next.u),
                    "v": float(s_next.v),
                    "w": float(s_next.w),
                },
                "meas": {k: float(v) if np.isfinite(v) else None for k, v in meas.items()},
                "wind_ned": {"n": float(w_ned[0]), "e": float(w_ned[1]), "d": float(w_ned[2])},
                "controls": {"cmd": asdict(u_cmd), "act": asdict(u)},
                "targets": {
                    "V": float(self.targets.airspeed_mps),
                    "alt": float(self.targets.altitude_m),
                    "hdg_deg": float(np.rad2deg(self.targets.heading_rad)),
                },
                "ap": ap_debug,
            }

            self.last_packet = packet
            return packet


runtime = SimRuntime()

def _linearize_full(x0: np.ndarray, u0: np.ndarray, params: AircraftParameters) -> tuple[np.ndarray, np.ndarray]:
    def f(x: np.ndarray, u_vec: np.ndarray) -> np.ndarray:
        ctrl = ControlInputs(
            throttle=float(u_vec[0]),
            aileron=float(u_vec[1]),
            elevator=float(u_vec[2]),
            rudder=float(u_vec[3]),
        )
        return xdot_full(x, ctrl, params=params)

    A, B = linearize(f, x0, u0)
    return A, B


@app.post("/api/v1/aircraft/select")
def select_aircraft(payload: Dict[str, Any]) -> Dict[str, Any]:
    aircraft_id = payload.get("aircraft_id") or payload.get("id")
    if not aircraft_id:
        return {"error": "Missing 'aircraft_id' in request body."}

    try:
        meta = runtime.select_aircraft(str(aircraft_id))
        model = get_aircraft_model(str(aircraft_id))
    except KeyError as exc:
        return {"error": str(exc)}

    return {
        "selected_aircraft": meta,
        "geometry": {
            "wingArea": model.geometry.wing_area,
            "wingspan": model.geometry.wingspan,
            "meanAerodynamicChord": model.geometry.mean_aerodynamic_chord,
            "tailArm": model.geometry.tail_arm,
            "cgLocation": model.geometry.cg_location,
        },
        "inertia": {
            "mass": model.inertia.mass,
            "Ixx": model.inertia.Ixx,
            "Iyy": model.inertia.Iyy,
            "Izz": model.inertia.Izz,
            "Ixz": model.inertia.Ixz,
        },
        "aero": {
            "Xu": model.aero_derivatives.Xu,
            "Xw": model.aero_derivatives.Xw,
            "Zu": model.aero_derivatives.Zu,
            "Zw": model.aero_derivatives.Zw,
            "Mu": model.aero_derivatives.Mu,
            "Mw": model.aero_derivatives.Mw,
            "Mq": model.aero_derivatives.Mq,
            "Yv": model.aero_derivatives.Yv,
            "Lv": model.aero_derivatives.Lv,
            "Lp": model.aero_derivatives.Lp,
            "Nr": model.aero_derivatives.Nr,
        },
        "metadata": model.metadata,
    }


@app.post("/api/v1/analysis/trim")
def compute_trim(payload: Dict[str, Any]) -> Dict[str, Any]:
    V_mps = float(payload.get("V_mps", 60.0))
    params = runtime.params
    trim = compute_level_trim_guess(V_mps, params)

    return {
        "aircraft_id": runtime.selected_aircraft_id,
        "V_mps": V_mps,
        "x0": trim.x0.tolist(),
        "u0": trim.u0.tolist(),
        "alpha_rad": trim.alpha,
        "throttle": trim.throttle,
        "elevator_rad": trim.elevator,
        "residual_norm": trim.residual_norm,
    }


@app.post("/api/v1/analysis/linearize")
def compute_linearization(payload: Dict[str, Any]) -> Dict[str, Any]:
    V_mps = float(payload.get("V_mps", 60.0))
    params = runtime.params
    model = get_aircraft_model(runtime.selected_aircraft_id)

    trim = compute_level_trim_guess(V_mps, params)
    if trim.residual_norm > 2.5:
        return {
            "error": "Trim residual too large for linearization.",
            "residual_norm": trim.residual_norm,
        }

    A, B = _linearize_full(trim.x0, trim.u0, params)
    eigvals = np.linalg.eigvals(A)
    eig_list = [{"real": float(ev.real), "imag": float(ev.imag)} for ev in eigvals]

    if model.stability_mode == "relaxed":
        if not any(ev.real > 0.0 for ev in eigvals):
            return {
                "error": "Relaxed-stability aircraft must exhibit at least one unstable eigenvalue (Re>0).",
                "eigenvalues": eig_list,
            }

    return {
        "aircraft_id": runtime.selected_aircraft_id,
        "V_mps": V_mps,
        "trim": {
            "x0": trim.x0.tolist(),
            "u0": trim.u0.tolist(),
            "alpha_rad": trim.alpha,
            "throttle": trim.throttle,
            "elevator_rad": trim.elevator,
            "residual_norm": trim.residual_norm,
        },
        "A": A.tolist(),
        "B": B.tolist(),
        "eigenvalues": eig_list,
    }

@app.websocket("/ws")
async def ws_endpoint(ws: WebSocket):
    await ws.accept()
    try:
        while True:
            # non-blocking receive for commands
            try:
                msg = await asyncio.wait_for(ws.receive_text(), timeout=0.0)
                data = json.loads(msg)
                _handle_command(data)
            except asyncio.TimeoutError:
                pass

            pkt = runtime.step()
            await ws.send_text(json.dumps(pkt))
            await asyncio.sleep(runtime.dt)
    except WebSocketDisconnect:
        return


def _handle_command(data: Dict[str, Any]) -> None:
    t = data.get("type")
    if t == "set_targets":
        runtime.set_targets(V=data.get("V"), alt=data.get("alt"), hdg_deg=data.get("hdg_deg"))
    elif t == "set_wind":
        runtime.set_wind(float(data.get("n", 0.0)), float(data.get("e", 0.0)), float(data.get("d", 0.0)))
    elif t == "set_autopilot":
        runtime.set_autopilot(bool(data.get("enabled", True)))



