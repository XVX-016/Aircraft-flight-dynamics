from __future__ import annotations

import asyncio
import json
import threading
import time
from dataclasses import asdict
from typing import Any, Dict, Optional

import numpy as np
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles

from aircraft_simulator.sim.aircraft.aerodynamics import ControlInputs
from aircraft_simulator.sim.aircraft.forces_moments import ActuatorLimits, forces_and_moments_body
from aircraft_simulator.sim.aircraft.parameters import AircraftParameters
from aircraft_simulator.sim.control.actuators import ActuatorState
from aircraft_simulator.sim.control.autopilot import Autopilot, AutopilotTargets
from aircraft_simulator.sim.control.failure_modes import FailureManager
from aircraft_simulator.sim.dynamics.equations import derivatives_6dof, post_step_sanitize, rotation_body_to_inertial
from aircraft_simulator.sim.dynamics.integrator import rk4_step
from aircraft_simulator.sim.environment.wind import WindModel
from aircraft_simulator.sim.sensors.airspeed import AirspeedSensor
from aircraft_simulator.sim.sensors.altimeter import Altimeter
from aircraft_simulator.sim.sensors.compass import Compass
from aircraft_simulator.sim.sensors.imu import IMU
from aircraft_simulator.sim.state import State


from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent
FRONTEND_DIR = BASE_DIR / "frontend"
PLOTS_DIR = BASE_DIR / "plots"

app = FastAPI(title="Aircraft Simulator API", version="0.1.0")

# Serve frontend (+ plots generated by scripts)
if FRONTEND_DIR.exists():
    app.mount("/static", StaticFiles(directory=str(FRONTEND_DIR), html=True), name="static")
if PLOTS_DIR.exists():
    app.mount("/static/plots", StaticFiles(directory=str(PLOTS_DIR), html=False), name="plots")


@app.get("/")
def root() -> FileResponse:
    index_path = FRONTEND_DIR / "index.html"
    if index_path.exists():
        return FileResponse(str(index_path))
    return {"error": "Frontend index.html not found"}


class SimRuntime:
    def __init__(self):
        self.lock = threading.Lock()

        self.params = AircraftParameters()
        self.limits = ActuatorLimits()

        self.state = State(x=0.0, y=0.0, z=-1000.0, u=35.0, v=0.0, w=0.0)
        self.t = 0.0

        self.dt = 0.02
        self.running = False

        self.targets = AutopilotTargets(airspeed_mps=35.0, altitude_m=1000.0, heading_rad=0.0)
        self.autopilot_enabled = True

        self.ap = Autopilot()
        self.act = ActuatorState(tau_s=0.15, limits=self.limits)
        self.act.reset(ControlInputs(throttle=0.5))
        self.failures = FailureManager()

        self.seed = 7
        self.wind = WindModel(steady_ned_mps=np.zeros(3), seed=self.seed)
        self.altimeter = Altimeter(seed=self.seed + 1)
        self.airspeed_sensor = AirspeedSensor(seed=self.seed + 2)
        self.compass = Compass(seed=self.seed + 3)
        self.imu = IMU(seed=self.seed + 4)

        self.last_packet: Dict[str, Any] = {}

    def set_wind(self, n: float, e: float, d: float) -> None:
        with self.lock:
            self.wind.steady_ned_mps = np.array([n, e, d], dtype=float)

    def set_targets(self, V: Optional[float] = None, alt: Optional[float] = None, hdg_deg: Optional[float] = None) -> None:
        with self.lock:
            self.targets = AutopilotTargets(
                airspeed_mps=self.targets.airspeed_mps if V is None else float(V),
                altitude_m=self.targets.altitude_m if alt is None else float(alt),
                heading_rad=self.targets.heading_rad if hdg_deg is None else float(np.deg2rad(hdg_deg)),
            )

    def set_autopilot(self, enabled: bool) -> None:
        with self.lock:
            self.autopilot_enabled = bool(enabled)

    def step(self) -> Dict[str, Any]:
        with self.lock:
            s = self.state
            t = self.t
            dt = self.dt

            self.failures.step(t)

            x = s.as_vector()
            params = self.params
            limits = self.limits

            # wind, body transform
            w_ned = self.wind.step(dt)
            C_bi = rotation_body_to_inertial(s.phi, s.theta, s.psi)
            w_body = C_bi.T @ w_ned
            v_b = np.array([s.u, s.v, s.w], dtype=float)
            v_air_b = v_b - w_body

            # gravity in body for IMU
            g_i = np.array([0.0, 0.0, params.g_ms2], dtype=float)
            g_b = C_bi.T @ g_i

            meas: Dict[str, float] = {
                "altitude_m": self.altimeter.read(t, -float(s.z), dt),
                "airspeed_mps": self.airspeed_sensor.read(t, float(np.linalg.norm(v_air_b)), dt),
                "heading_rad": self.compass.read(t, float(s.psi), dt),
                "phi_rad": float(s.phi),
                "theta_rad": float(s.theta),
            }
            meas.update(
                self.imu.read(
                    t,
                    pqr_radps=np.array([s.p, s.q, s.r], dtype=float),
                    uvw_mps=v_b,
                    g_b_ms2=g_b,
                    dt=dt,
                )
            )
            meas = self.failures.apply_sensors(meas)

            u_cmd = ControlInputs(throttle=0.5)
            ap_debug: Dict[str, float] = {}
            if self.autopilot_enabled:
                u_cmd, ap_debug = self.ap.update(meas, self.targets, dt)
            u_cmd = self.failures.apply_actuator(u_cmd)
            u = self.act.update(u_cmd, dt)

            # dynamics (wind held constant within step)
            def f_dyn(ti: float, xi: np.ndarray) -> np.ndarray:
                si = State.from_vector(xi)
                C_bi_i = rotation_body_to_inertial(si.phi, si.theta, si.psi)
                w_body_i = C_bi_i.T @ w_ned
                v_b_i = np.array([si.u, si.v, si.w], dtype=float)
                v_air_b_i = v_b_i - w_body_i
                F, M, _ = forces_and_moments_body(si, u, params, limits, uvw_air_mps=v_air_b_i)
                return derivatives_6dof(ti, xi, params, F, M)

            x = rk4_step(f_dyn, t, x, dt)
            x = post_step_sanitize(x)
            s_next = State.from_vector(x)

            self.state = s_next
            self.t = t + dt

            packet = {
                "t": float(self.t),
                "truth": {
                    "x": float(s_next.x),
                    "y": float(s_next.y),
                    "z": float(s_next.z),
                    "altitude_m": -float(s_next.z),
                    "phi": float(s_next.phi),
                    "theta": float(s_next.theta),
                    "psi": float(s_next.psi),
                    "u": float(s_next.u),
                    "v": float(s_next.v),
                    "w": float(s_next.w),
                },
                "meas": {k: float(v) if np.isfinite(v) else None for k, v in meas.items()},
                "wind_ned": {"n": float(w_ned[0]), "e": float(w_ned[1]), "d": float(w_ned[2])},
                "controls": {"cmd": asdict(u_cmd), "act": asdict(u)},
                "targets": {
                    "V": float(self.targets.airspeed_mps),
                    "alt": float(self.targets.altitude_m),
                    "hdg_deg": float(np.rad2deg(self.targets.heading_rad)),
                },
                "ap": ap_debug,
            }

            self.last_packet = packet
            return packet


runtime = SimRuntime()


@app.websocket("/ws")
async def ws_endpoint(ws: WebSocket):
    await ws.accept()
    try:
        while True:
            # non-blocking receive for commands
            try:
                msg = await asyncio.wait_for(ws.receive_text(), timeout=0.0)
                data = json.loads(msg)
                _handle_command(data)
            except asyncio.TimeoutError:
                pass

            pkt = runtime.step()
            await ws.send_text(json.dumps(pkt))
            await asyncio.sleep(runtime.dt)
    except WebSocketDisconnect:
        return


def _handle_command(data: Dict[str, Any]) -> None:
    t = data.get("type")
    if t == "set_targets":
        runtime.set_targets(V=data.get("V"), alt=data.get("alt"), hdg_deg=data.get("hdg_deg"))
    elif t == "set_wind":
        runtime.set_wind(float(data.get("n", 0.0)), float(data.get("e", 0.0)), float(data.get("d", 0.0)))
    elif t == "set_autopilot":
        runtime.set_autopilot(bool(data.get("enabled", True)))



